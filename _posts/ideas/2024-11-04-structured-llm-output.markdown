---
layout: post
title:  关于大语言模型的结构化输出
date:   2024-11-03 21:42:10 -0600
categories: [点子]
---

> 这次比上次听起来有意思一些
>
> ——𝒦
{: .prompt-info }

大语言模型可以在输出结构化内容的时候，将其显式地呈现为树状结构，例如：为各个树节点编号，输出元标签来将当前输出的“光标”在各个节点之间切换。

一个输出实例：

```plaintext
[<<1>>, <<2>>]
<<1>>: {"languages": <<3>>, "country": "Singapore"}
<<2>>: {"country": "United States", "languages": "English"}
<<3>>: ["English", "Chinese", ...]
```

> 省略部分为记不得了
{: .prompt-tip }

这只是演示用例，实际上并不需要真的输出这种标签，而是通过集成在模型输出中的控制信号来表示的。这是一个对大语言模型的定制修改。

核心思想：输出树状结构的子节点和接下来的兄弟节点是两个没有依赖性的独立任务。比如上面的例子中，输出1号节点和输出2号节点没有先后依赖关系，1号节点的后半部分和3号节点也没有。

大语言模型的输出是顺序的线性扁平化文本，这是一种过度严格的限制。

----

首先我们可以并行化输出树的各个部分，增加推理性能。

在分叉出子节点的时候，将当前任务分解为可并行的两个子任务：一个继续输出子节点的内容然后就结束，一个继续输出当前节点。

两个任务自然要以不同的状态开始接下来的token生成，因此分叉子节点需要特殊实现。

----

其次，这可以使子节点的长度不影响后续回到父节点以后的内容输出。

一个极端例子是如果3号节点的长度超出窗口长度，那么在回到1号节点以后，内容可能就会变成乱吐token。

通过在输出1号节点的任务中完全跳过对3号节点的输出，就可以确保1号节点的内容完全不受3号节点内容长度的影响。
